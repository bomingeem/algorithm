시간 복잡도
 · 표기법으로 대문자 O를 사용한다
 · Big O Notation
 · 입력의 크기 N에 대해서 시간이 얼마나 걸릴지 나타내는 방법
 · 즉, 최악의 경우에 시간이 얼마나 걸릴지 알 수 있다
 · 시간 복잡도는 소스를 보고 계산할 수도 있고, 소스를 작성하기 전에 먼저 계산해볼 수 있다
 · 문제를 풀기 전에 먼저 생각한 방법의 시간 복잡도를 계산해보고 이게 시간 안에 수행될 것 같은 경우에만 구현하는 것이 좋다
 · 시간 복잡도 안에 가장 큰 입력 범위를 넣었을 때, 1억이 1초정도이다
 · 이 값은 대략적인 값으로, 실제로 구현해보면 1억을 조금 넘어도 1초 이내에 수행이 가능하다
 
 · Big O Notation에서 상수는 버린다
   · O(3N^2) = O(N^2)
   · O(1/2N^2) = O(N^2)
   · O(5) = O(1)
 · 두가지 항이 있을 때, 변수가 같으면 큰 것만 빼고 다 버린다
   · O(N^2 + N) = O(N^2)
   · O(N^2 + NlgN) = O(N^2)
 · 두가지 항이 있는데 변수가 다르면 놔둔다
   · O(N^2 + M)
  
메모리
 · 메모리 제한은 보통 넉넉하기 때문에 걱정할 필요가 없다
 · 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다
 · 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다
 
입/출력
 · Java는 입력은 Scanner, 출력은 System.out을 사용한다 
   Scanner sc = new Scanner(System.in);
 · 입력이 많은 경우에는 속도가 느리기 때문에 BufferedReader를 사용한다
   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 · 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용하거나 BufferedWriter를 사용한다

스택(Stack)
 · 스택은 한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조
 · 마지막으로 넣은 것이 가장 먼저 나오기 때문에 LIFO(Last In First Out) 라고도 한다
 · push : 스택에 자료를 넣는 연산
 · pop : 스택에서 자료를 빼는 연산
 · top : 스택의 가장 위에 있는 자료를 보는 연산
 · empty : 스택이 비어있는지 아닌지를 알아보는 연산
 · size : 스택에 저장되어있는 자료의 개수를 알아보는 연산
스택의 구현
 · 일차원 배열 하나로 구현할 수 있다

큐(Queue)
 · 한쪽 끝에서만 자료를 넣고 다른 한쪽 끝에서만 뺄 수 있는 자료구조
 · 먼저 넣은 것이 가장 먼저 나오기 때문에 FIFO(First In First Out) 라고도 한다
 · push : 큐에 자료를 넣는 연산
 · pop : 큐에 자료를 빼는 연산
 · front : 큐의 가장 앞에 있는 자료를 보는 연산
 · back : 큐의 가장 뒤에 있는 자료를 보는 연산
 · empty : 큐가 비어있는지 아닌지를 알아보는 연산
 · size : 큐에 저장되어있는 자료의 개수를 알아보는 연산
큐의 구현
 · 일차원 배열 하나로 구현할 수 있다 (큐에 포함되어 있는 내용은 begin,end 이다)

덱(Deque)
 · 양쪽 끝에서만 자료를 넣고 양 끝에서만 뺄 수 있는 자료구조
 · push_front : 덱의 앞에 자료를 넣는 연산
 · push_back : 덱의 뒤에 자료를 넣는 연산
 · pop_front : 덱의 앞에서 자료를 빼는 연산
 · pop_back : 덱의 뒤에서 자료를 빼는 연산
 · front : 덱의 가장 앞에 있는 자료를 보는 연산
 · back : 덱의 가장 뒤에 있는 자료를 보는 연산

수학
나머지 연산
 · 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 등장
최대공약수
 · 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다
 · 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B)까지 모든 정수로 나누어 보는 방법
 · 최대공약수가 1인 두 수를 서로소라고 한다
유클리드 호제법을 이용하는 방법
 · a를 b로 나눈 나머지를 r이라고 했을 때
 · GCD(a,b) = GCD(b,r)과 같다
 · r이 0이면 그 때 b가 최대 공약수이다
 · GCD(24,16) = GCD(16,8) = GCD(8,0) = 8
최소공배수
 · 두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수
 · 두 수 a,b의 최대공약수를 g라고 했을 때 최소공배수 l = g * (a/g) * (b/g)이다
소수
 · 소수 : 약수가 1과 자기 자신밖에 없는 수
 · N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다
소수와 관련된 알고리즘
 1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
    - N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다
      이유 : N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문
    - N이 소수가 되려면, 2보다 크거나 같고, 루트N보다 작거나 같은 자연수로 나누어 떨어지면 안된다
      이유 : N이 소수가 아니라면, N = a x b로 나타낼 수 있다
      컴퓨터에서 실수는 근사값을 나타내기 때문에 루트 N은 i <= N*N과 같다
 2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방
    - 에라토스테네스의 체 (소수를 구할 경우, 무조건 제일 좋은 방법)
      지워지지 않은 수 중에서 가장 작은 수는 2이다
      2는 소수이고 2의 배수를 모두 지운다
      3의 배수를 지운다
      5의 배수를 지운다
      7의 배수를 지운다
      11의 배수는 이미 지워져있다
      2,3,5,7로 인해서 11x11은 121로 100을 넘기 때문에 더 이상 수행할 필요가 없다
      남아있는 모든 수가 소수이다
      1부터 N까지 모든 소수를 구하는 것이 목표이기 때문에 구현할 때는 바깥 for문 (i)를 N까지 도린다
      안쪽 for문 (j)는 N의 크기에 따라서, i*i 또는 i*2로 바꾸는 것이 좋다
      i=백만인 경우 i*i는 범위를 넘어가기 때문
    - 골드바흐의 추측
      2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능
      5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능
      아직 증명되지 않은 문제
팩토리얼
 · N! = 1x2x...xN
 · 팩토리얼은 매우 큰 값
팩토리얼 0의 개수
 · N!의 0이 몇개인지 알아내려면 N!을 소인수분해 했을 때, 2와 5가 몇개 나오는지 알아야 한다
 · 5의 개수가 항상 2의 개수보다 적기 때문에 5의 개수만 세어주면 된다
   100!의 경우 인수가 5가 들어가는 것을 찾아보자
   여기서 25,50,75,100은
   5가 두개씩 들어간다 
   100/25 = 4
   25,50,75,100
   따라서 100!의 0의 개수는 20+4 = 24개이다
 